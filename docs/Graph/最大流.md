[讲课链接](https://www.bilibili.com/video/BV1i8411K7PZ/?spm_id_from=333.999.0.0)

## 常见技巧
### 超级源点和超级汇点
多源点或者多汇点，建立超级源和超级汇，把所有的题目中的可行源点和汇点分别连接到超级源和超级汇上
### 拆点
点权，把一个点拆成入点和出点，即可转化为边权

割点，把一个点拆成入点和出点，即可转化为割边

按照时间拆点，把这些点拆成总时间这么多个点，然后每个点向下一秒的自己连边，如果从A点到B点需要3秒，那么每一秒的A点向3秒后的B点连边，能解决限定时间的最大流问题
### 加点
同一点集合内任意两点边权一样，不同集合间的点边权不一样，那么每个集合都增加一个点，所有集合内的点向该点连边
[参考资料](https://www.cnblogs.com/victorique/p/8560656.html#autoid-1-9-14)
## 常见结论
割：把图分为两部分，一个点要么在源点所在的图，要么在汇点所在的图，两个原来有边的点，被分割到两个图后，这个边被割掉

割的容量：割掉的边的边权之和

最小割：容量最小的割

最小割=最大流。

最大权闭合图=全选-最小割。

闭合图：在一个图中，我们选取一些点构成集合，记为V，且集合中的出边，所指向的终点(弧头)也在V中

闭合图的权：集合中，点权值之和

最大权闭合图：权最大的闭合图

二分图最大匹配=最大流。

二分图最小点覆盖：选最少的点，满足每条边至少有一个端点被选。

二分图最小点覆盖=最大流。

二分图最大独立集：选最多的点，满足两两之间没有边相连。

二分图最大独立集=点数-最小覆盖数。

二分图最小路径覆盖：有向无环图G，要求用尽量少的不相交的简单路径覆盖所有的节点 。

二分图最小路径覆盖=原图节点数-最大匹配.
## 板子

```c++
struct flownode{
    int to, next;
    ll w;
};
struct MaxFlow{
private:
    #define ll long long
    #define MAXN  205
    #define MAXM  (MAXN * MAXN * 2)
    flownode edge[MAXM];
    int head[MAXN], cnt;
    int deep[MAXN];
    ll inf = 0x3f3f3f3f3f3f3f3f;
    std::queue<int> q;
public:
    int st, ed;
    MaxFlow(int st, int ed): st(st), ed(ed){
        memset(head, -1, sizeof(head));
        cnt = -1;
    }
    void add(int u, int v, ll w){
        addedge(u, v, w);
        addedge(v, u, 0);
    }
    void addedge(int u, int v, ll w){
        edge[++cnt].to = v;
        edge[cnt].w = w;
        edge[cnt].next = head[u];
        head[u] = cnt;
    }
    int bfs(void){
        memset(deep, 0, sizeof(deep));
        q.push(st);
        deep[st] = 1;
        while(!q.empty()){
            int now = q.front();
            q.pop();
            for(int i = head[now]; ~i;i = edge[i].next){
                int to = edge[i].to;
                if(edge[i].w && !deep[to]){
                    deep[to] = deep[now] + 1;
                    q.push(to);
                }
            }
        }
        return deep[ed] != 0;
    }
    ll dfs(int now, ll fl){
        if(now == ed) return fl;
        ll f = 0;
        for(int i = head[now];~i;i = edge[i].next){
            int to = edge[i].to;
            if(edge[i].w && deep[to] == deep[now] + 1){
                int x = dfs(to, min(fl, edge[i].w));
                edge[i].w -= x;
                edge[i ^ 1].w += x;
                f += x;
                fl -= x;
            }
        }
        if(!f) deep[now] = -1;
        return f;
    }
    ll Maxflow(void){
        ll ans = 0;
        while(bfs()){
            ans += dfs(st, inf);
        }
        return ans;
    }
};
```
